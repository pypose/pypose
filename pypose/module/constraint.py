import pypose as pp
import torch as torch
import torch.nn as nn
from .. import excludeBatch
from torch.autograd.functional import jacobian

class Constraint(nn.Module):
    r'''
    The base class of a constraint function.

    The inequality constraint :math:`\mathrm{cons} \leq \mathbf{0}` with

    .. math::
        \begin{aligned}
            \mathrm{cons} = \mathrm{cons}(\mathbf{x}_k, \mathbf{u}_k)
        \end{aligned}

    where :math:`\mathbf{x}_{k}`, :math:`\mathbf{u}_{k}` are the state and input at time instant :math:`k`, respectively.


    Note:
        More practical examples can be found at `examples/module/constraint
        <https://github.com/pypose/pypose/tree/main/examples/module/constraint>`_.
    '''

    def __init__(self, cdim = None):
        super().__init__()
        self.jacargs = {'vectorize':True, 'strategy':'reverse-mode'}
        # self.jacargs = {'vectorize':False, 'strategy':'reverse-mode'}
        self._cdim = cdim

    def forward(self, state, input):
        r'''
        Defines the computation.

        '''
        self.state, self.input = torch.atleast_1d(state), torch.atleast_1d(input)
        return self.constraint(self.state, self.input)

    def constraint(self, state, input, t=None):
        r'''
        Args:
            state (:obj:`Tensor`): The state of the dynamical system
            input (:obj:`Tensor`): The input to the dynamical system

        Returns:
            Tensor: The stage constraint of the system
        '''
        raise NotImplementedError("The users need to define their own state transition method")

    def set_refpoint(self, state=None, input=None):
        r'''
        Function to set the reference point for linearization.

        Args:
            state (:obj:`Tensor`): The reference state of the dynamical system. If ``None``,
                the the most recent state is taken. Default: ``None``.
            input (:obj:`Tensor`): The reference input to the dynamical system. If ``None``,
                the the most recent input is taken. Default: ``None``.

        Returns:
            None

        Warning:
            For nonlinear systems, the users have to call this function before getting the
            linearized system.
        '''
        self._ref_state = torch.tensor(self.state) if state is None else torch.atleast_1d(state)
        self._ref_input = torch.tensor(self.input) if input is None else torch.atleast_1d(input)
        self._ref_c = self.constraint(self._ref_state, self._ref_input)

    @property
    def cdim(self):
        r'''
        dim of constraint
        '''
        return self._cdim

    @property
    def gx(self):
        r'''
        Linear/linearized constraint term on state

        .. math::
            \mathbf{g}_{\mathbf_{x}} = \left. \frac{\partial \mathbf{g}}{\partial \mathbf{x}} \right|_{\chi^*}
        '''
        func = lambda x: self.constraint(x, self._ref_input)
        return excludeBatch(jacobian(func, self._ref_state, **self.jacargs), type=2)

    @property
    def gu(self):
        r'''
        Linear/linearized constraint term on input

        .. math::
            \mathbf{g}_{\mathbf_{u}} = \left. \frac{\partial \mathbf{g}}{\partial \mathbf{u}} \right|_{\chi^*}
        '''
        func = lambda u: self.constraint(self._ref_state, u)
        return excludeBatch(jacobian(func, self._ref_input, **self.jacargs), type=2)

    @property
    def g(self):
        r'''
        Constant term generated by constraint.

        .. math::
            \mathbf{g} = \mathrm{cons}(\mathbf{x}^*, \mathbf{u}^*, t^*)
                           - \mathbf{g}_{\mathbf{x}}\mathbf{x}^* - \mathbf{g}_{\mathbf{u}}\mathbf{u}^*
        '''
        # Potential performance loss here - self.A and self.B involves jacobian eval
        return self._ref_c - pp.bmv(self.gx, self._ref_state) - pp.bmv(self.gu, self._ref_input)

class LinCon(Constraint):
    r'''
    Linear inequlity constraint.

    Args:
        gx (:obj:`Tensor`): The state coefficient of linear constraint.
        gu (:obj:`Tensor`): The input coefficient of linear constraint.
        g (:obj:`Tensor`): The constant term of linear constraint.

    A linear inequality constraint :math:`\mathrm{cons} \leq \mathbf{0}` with

    .. math::
        \begin{align*}
            \mathrm{cons} = \mathbf{g}_{\mathbf{x}}\mathbf{x} + \mathbf{g}_{\mathbf{u}}\mathbf{u} + \mathbf{g}
        \end{align*}

    where :math:`\mathbf{x}` and :math:`\mathbf{u}` are state and input of the current
    timestamp of system.

    Note:
        The variables including state and input are row vectors, which is the last dimension of
        a Tensor. :obj:`gx`, :obj:`gu`, :obj:`g`.

    Example:
        >>> gx = torch.randn(2, 3)
        >>> gu = torch.randn(2, 2)
        >>> g = torch.randn(2, 1)
        >>> state = torch.randn(1, 3)
        >>> input = torch.randn(1, 2)
        >>> lincon = pp.module.LinCon(gx,gu,g)
        >>> print(lincon(state, input))
        >>> print(lincon.gx)
    '''

    def __init__(self, gx, gu, g=None):
        super(LinCon, self).__init__(gx.shape[-2])
        # assert gx.ndim in (2, 3), "Invalid constraint state coefficient dimensions"
        assert gx.ndim == gu.ndim, "Invalid coefficient matrices dimensions"
        self.register_buffer('_gx', gx)
        self.register_buffer('_gu', gu)
        self.register_buffer('_g', g)

    def forward(self, state, input):
        r'''
        Perform computation for the linear constraint.

        '''
        if self.gx.ndim >= 3:
            assert self.gx.ndim == (state.ndim+1) == (input.ndim+1),  "Invalid coefficient matrices dimensions"

        return super(LinCon, self).forward(state, input)

    def constraint(self, state, input):
        r'''
        Perform computation for the linear constraint.

        .. math::
            \mathrm{cons} = \mathbf{g}_{\mathbf{x}}\mathbf{x} + \mathbf{g}_{\mathbf{u}}\mathbf{u} + \mathbf{g} \\

        '''
        return pp.bmv(self.gx, state) + pp.bmv(self.gu, input) \
                        + self.g

    @property
    def gx(self):
        r'''
        State coefficient matrix :obj:`gx`
        '''
        return self._gx

    @property
    def gu(self):
        r'''
        Input coefficient matrix :obj:`gu`
        '''
        return self._gu

    @property
    def g(self):
        r'''
        Constant :obj:`g`
        '''
        return self._g
