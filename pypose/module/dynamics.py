import torch as torch
import torch.nn as nn
import pypose as pp
from torch.autograd import Variable

class _System(nn.Module):
    def __init__(self,time=False):
        super().__init__()
        if time:
            self.register_buffer('t',torch.zeros(1))
            self.register_forward_hook(self.timeplus1)

    def timeplus1(self,module,inputs,outputs):
        self.t.add_(1)

    def forward(self,state,input):
        state = self.state_transition(state,input)
        return self.observation(state,input)
    
    def state_trasition(self):
        pass

    def observation(self):
        pass
    
    def reset(self,t=0):
        self.t.fill_(0)
        
    @property
    def A(self):
        pass
    
    @property
    def B(self):
        pass
    
    @property
    def C(self):
        pass
    
    @property
    def D(self):
        pass

class LTI(_System):
    
    r'''
    A sub-class of: obj: '_System' to represent Linear Time-Invariant system.
    
    Args:
        A,B,C,D (:obj:`Tensor`): The input tensor in the state-space equation of LTI system,
            usually in matrix form.
        c1, c2 (:obj:`Tensor`): Bias generated by system.
        
    Note:
        According to the actual physical meaning, the dimensions of ABCD must be the same,
        whether in the batch case or not.
        
        time = False means the system is time invariant.
    '''
    
    def __init__(self, A, B, C, D, c1=None, c2=None, time = False):
        super(LTI, self).__init__()
        
        assert A.ndimension() == B.ndimension() == C.ndimension() == D.ndimension()

        self.A = A
        self.B = B
        self.C = C
        self.D = D
        self.c1 = c1
        self.c2 = c2
    
    @property
    def A(self):
        return self.A
    
    @property
    def B(self):
        return self.B
    
    @property
    def C(self):
        return self.C
    
    @property
    def D(self):
        return self.D
    
    @property
    def c1(self):
        return self.c1
    
    @property
    def c2(self):
        return self.c2
    
    def forward(self, x, u):
        r'''
        Parameters
        ----------
        x : Tensor
            The state of LTI system
        u : Tensor
            The input of LTI system

        Returns
        -------
        z : Tensor
            Derivative of x in discrete case, state-transition
        y : Tensor
            The output of LTI system, observation
            
        Note:
            -x, u could be single input or multiple inputs
             For a single input x,u is one dimensional and the system will 
             perform the corresponding dimension raising and lowering operations 
             to ensure the correctness of the calculation.
            -A,B,C,D can only be two-dimensional matrices or the batch
             In the batch case, their dimensions must be the same as those of u,x 
             A,B,C,D and u,x are multiplied separately for each channel.
            -For a System with p inputs, q outputs, and n state variables,
             A,B,C,D are n*n n*p q*n and q*p constant matrices.
            -Note that variables are entered as row vectors.
        
        Example:
            >>> A = torch.randn((3,3))
                B = torch.randn((3,2))
                C = torch.randn((3,3))
                D = torch.randn((3,2))
                c1 = torch.randn((2,1,3))
                c2 = torch.randn((2,1,3))
                x = torch.randn((2,1,3))
                u = torch.randn((2,1,2))
            >>> A
            tensor([[ 0.3925, -0.1799, -0.0653],
                    [-0.6016,  1.9318,  1.1651],
                    [-0.3182,  1.4565,  1.0184]]) 
                B
            tensor([[-0.4794, -1.7299],
                    [-1.1820, -0.0606],
                    [-1.2021, -0.5444]]) 
                C
            tensor([[-0.1721,  1.6730, -0.6955],
                    [-0.4956,  1.3174,  0.3740],
                    [-0.0835,  0.3706, -1.9351]])
                D
            tensor([[ 1.9300e-01, -1.3445e+00],
                    [ 2.6992e-01, -9.1387e-01],
                    [-6.3274e-04,  5.1283e-01]]) 
                c1
            tensor([[[-0.8519, -0.6737, -0.3359]],
                    [[ 0.5543, -0.1456,  1.4389]]]) 
                c2
            tensor([[[-0.7543, -0.6047, -0.6620]],
                    [[ 0.6252,  2.6831, -3.1711]]]) 
                x
            tensor([[[ 1.0022, -0.1371,  1.0773]],
                    [[ 0.7227,  0.7777,  1.0332]]]) 
                u
            tensor([[[1.7736, 0.7472]],
                    [[0.4841, 0.9187]]])
            >>> lti = LTI(A, B, C, D)
            tensor([[[-1.7951, -1.7544, -1.9603]],
                    [[-1.7451,  1.6436,  0.8730]]]), 
            tensor([[[-1.8134, -0.4785, -1.8370]],
                    [[-0.6836,  0.3439, -1.3006]]]))

        '''
        if not isinstance(x, Variable) and isinstance(self.A, Variable):
            A = self.A.data
            B = self.B.data
            C = self.C.data
            D = self.D.data
            c1 = self.c1.data if self.c1 is not None else 0.
            c2 = self.c2.data if self.c2 is not None else 0.
        else:
            A = self.A
            B = self.B
            C = self.C
            D = self.D
            c1 = self.c1 if self.c1 is not None else 0.
            c2 = self.c2 if self.c2 is not None else 0.

        x_dim, u_dim = x.ndimension(), u.ndimension()
        if x_dim == 1:
            x = x.unsqueeze(0)
        if u_dim == 1:
            u = u.unsqueeze(0)
            
        if A.ndimension() >= 3:
            assert A.ndimension() == B.ndimension() == C.ndimension() == D.ndimension() == x_dim == u_dim
        else:
            assert A.ndimension() == 2
            assert B.ndimension() == 2
            assert C.ndimension() == 2
            assert D.ndimension() == 2
            
        """
        if c1 is not None:
            assert c1.ndimension() == x_dim
        if c2 is not None:
            assert c2.ndimension() == x_dim
        """

        z = x.matmul(A.mT) + u.matmul(B.mT) + c1
        y = x.matmul(C.mT) + u.matmul(D.mT) + c2
        
        if x_dim == u_dim == 1:
            z = z.squeeze(0)
            y = y.squeeze(0)
           
        return z, y
